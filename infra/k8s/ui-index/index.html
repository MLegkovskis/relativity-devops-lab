<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Black Hole – Minimal UI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body { background:#05060a; color:#fff; font-family: system-ui, Arial; margin:0; }
      .bar { padding:12px; display:flex; gap:12px; align-items:center; }
      button { padding:8px 12px; border-radius:8px; border:0; background:#2ecc71; color:#000; font-weight:600; cursor:pointer; }
      #status { opacity:0.8; font-size:14px; }
      canvas { display:block; margin:12px; border:1px solid #222; }
    </style>
  </head>
  <body>
    <div class="bar">
      <button id="fire">Fire</button>
      <span id="status">Connecting…</span>
    </div>
    <canvas id="cv" width="1000" height="750"></canvas>

    <script>
      // --- Config (change if you mapped ports differently) ---
      const port = window.location.port || (window.location.protocol === "https:" ? "443" : "80");
      const portNum = Number(port);
      const USING_COMPOSE = port === "8080"; // docker-compose exposes UI on 8080
      const USING_NODEPORT = !USING_COMPOSE && portNum >= 30000;
      const nodeRayPort = USING_NODEPORT ? String(portNum + 1) : "";
      const nodeBhPort = USING_NODEPORT ? String(portNum + 2) : "";
      const RAY_API = USING_COMPOSE ? "http://localhost:8000" : USING_NODEPORT ? `http://localhost:${nodeRayPort}` : "/ray-api";
      const BH_API  = USING_COMPOSE ? "http://localhost:8001" : USING_NODEPORT ? `http://localhost:${nodeBhPort}` : "/blackhole-api";
      const mode = USING_COMPOSE ? "compose" : USING_NODEPORT ? "nodeport" : "cluster";
      function setStatus(msg) {
        document.getElementById('status').textContent = msg;
      }
      setStatus(`Mode=${mode} ui=${window.location.origin} ray=${RAY_API} bh=${BH_API}`);
      const MASS    = 8.54e36;
      const c       = 299792458.0;

      // --- Canvas + world mapping (match your sim’s meters) ---
      const cv = document.getElementById('cv');
      const ctx = cv.getContext('2d');
      const world = { w: 1e11, h: 7.5e10, ox: 0, oy: 0 };

      function worldToScreen(x, y) {
        const left = -world.w + world.ox, right = world.w + world.ox;
        const bottom = -world.h + world.oy, top = world.h + world.oy;
        const sx = ( (x - left) / (right - left) ) * cv.width;
        const sy = cv.height - ( (y - bottom) / (top - bottom) ) * cv.height;
        return [sx, sy];
      }

      // --- API helpers ---
      async function bhDerived(mass) {
        const r = await fetch(`${BH_API}/derived`, {
          method:'POST', headers:{'content-type':'application/json'},
          body: JSON.stringify({mass})
        });
        if (!r.ok) throw new Error(await r.text());
        return r.json();
      }

      async function integrateRay({mass, x, y, vx, vy, steps=3000, dlam=1.0}) {
        const r = await fetch(`${RAY_API}/integrate`, {
          method:'POST', headers:{'content-type':'application/json'},
          body: JSON.stringify({mass, x, y, vx, vy, steps, dlam})
        });
        if (!r.ok) throw new Error(await r.text());
        return r.json();
      }

      // --- State ---
      let rs = 0;
      const trails = []; // { trail: [[x,y],...], upto: int }

      // --- Draw ---
      function draw() {
        ctx.fillStyle = "#05060a"; ctx.fillRect(0,0,cv.width,cv.height);

        // black hole disc
        const [cx, cy] = worldToScreen(0,0);
        const [rx,_] = worldToScreen(rs,0);
        const rpx = Math.abs(rx - cx);
        ctx.fillStyle = "#e74c3c";
        ctx.beginPath(); ctx.arc(cx, cy, rpx, 0, Math.PI*2); ctx.fill();

        // trails with fade
        ctx.lineWidth = 1.2;
        for (const T of trails) {
          const N = Math.min(T.upto, T.trail.length);
          for (let i=1; i<N; i++) {
            const [x0,y0] = worldToScreen(T.trail[i-1][0], T.trail[i-1][1]);
            const [x1,y1] = worldToScreen(T.trail[i][0],   T.trail[i][1]);
            const a = Math.max(i / T.trail.length, 0.05);
            ctx.strokeStyle = `rgba(255,255,255,${a})`;
            ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
          }
          T.upto = Math.min(N + 6, T.trail.length); // reveal speed
        }

        requestAnimationFrame(draw);
      }

      // --- UI actions ---
      document.getElementById('fire').addEventListener('click', async () => {
        try {
          const x = - (0.1 + Math.random()*0.8) * world.w * 2;
          const y = (Math.random()*2 - 1) * world.h * 2 * 0.9;
          const data = await integrateRay({mass: MASS, x, y, vx: c, vy: 0, steps: 4000, dlam: 1.0});
          trails.push({ trail: data.trail, upto: 1 });
        } catch (e) {
          setStatus("Fire failed: " + e.message);
        }
      });

      // --- Boot ---
      (async function () {
        try {
          setStatus("Fetching BH…");
          const d = await bhDerived(MASS);
          rs = d.schwarzschild_radius;
          setStatus(`rs = ${rs.toFixed(3)} m`);

          // seed ray
          const seed = await integrateRay({mass: MASS, x: -1e11, y: 3.2760630272e10, vx: c, vy: 0, steps: 4000});
          trails.push({ trail: seed.trail, upto: 1 });

          draw();
        } catch (e) {
          setStatus("Startup error: " + e.message);
        }
      })();
    </script>
  </body>
</html>
